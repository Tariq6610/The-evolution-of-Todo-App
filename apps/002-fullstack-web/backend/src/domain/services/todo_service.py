"""TodoService business logic for task operations.

This service contains pure domain logic for todo operations.
Coordinates between ports and implements business rules.
No framework dependencies - pure domain logic.
"""

from src.domain.entities.priority import Priority
from src.domain.entities.task import Task
from src.domain.ports.storage_port import StoragePort


class TodoService:
    """
    Business logic service for todo operations.

    This service coordinates between ports and implements business rules.
    It contains pure domain logic with no framework dependencies.

    Attributes:
        storage: Storage adapter implementing StoragePort interface
    """

    def __init__(self, storage: StoragePort) -> None:
        """
        Initialize TodoService with storage adapter.

        Args:
            storage: Storage adapter implementing StoragePort
        """
        self.storage = storage

    def create_task(
        self,
        title: str,
        description: str | None = None,
        priority: Priority = Priority.MEDIUM,
        tags: list[str] | None = None,
    ) -> Task:
        """
        Create a new task with validation.

        Business Rules:
        - Title cannot be empty or whitespace
        - Unique ID generated via storage
        - Timestamps set to current time
        - Default status is PENDING

        Args:
            title: Task title (required)
            description: Optional detailed description
            priority: Task priority (default: MEDIUM)
            tags: Optional list of tags

        Returns:
            Created task with generated ID

        Raises:
            ValueError: If title is empty or whitespace
        """
        # Validation handled by Task entity (Pydantic)
        task = Task(
            id="",  # Placeholder, will be generated by storage
            title=title,
            description=description,
            priority=priority,
            tags=tags or [],
        )
        return self.storage.save(task)

    def get_all_tasks(
        self,
        search: str | None = None,
        status: str | None = None,
        priority: str | None = None,
        tag: str | None = None,
        sort_by: str | None = None,
    ) -> list[Task]:
        """
        Retrieve all tasks with optional filtering and sorting.

        Args:
            search: Filter by keyword in title or description
            status: Filter by status (PENDING or COMPLETED)
            priority: Filter by priority (LOW, MEDIUM, or HIGH)
            tag: Filter by tag
            sort_by: Sort by field (created_at, updated_at, title, priority, -priority)

        Returns:
            List of filtered and sorted tasks (empty list if none match)
        """
        return self.storage.get_all(
            search=search,
            status=status,
            priority=priority,
            tag=tag,
            sort_by=sort_by,
        )

    def update_task(
        self,
        task_id: str,
        title: str | None = None,
        description: str | None = None,
        priority: Priority | None = None,
        tags: list[str] | None = None,
    ) -> Task:
        """
        Update task fields.

        Only updates provided fields (partial update).

        Args:
            task_id: ID of task to update
            title: New title (optional)
            description: New description (optional)
            priority: New priority (optional)
            tags: New tags (optional)

        Returns:
            Updated task

        Raises:
            ValueError: If task_id not found or title is empty
        """
        existing_task = self.storage.get(task_id)
        if existing_task is None:
            raise ValueError(f"Task with ID '{task_id}' not found")

        # Build update dict with only non-None values
        updates: dict[str, object] = {}
        if title is not None:
            updates["title"] = title
        if description is not None:
            updates["description"] = description
        if priority is not None:
            updates["priority"] = priority
        if tags is not None:
            updates["tags"] = tags

        # Create updated task
        updated_task = existing_task.model_copy(update=updates)
        return self.storage.update(task_id, updated_task)

    def delete_task(self, task_id: str) -> None:
        """
        Delete a task by ID.

        Args:
            task_id: ID of task to delete

        Raises:
            ValueError: If task_id not found
        """
        if not self.storage.exists(task_id):
            raise ValueError(f"Task with ID '{task_id}' not found")
        self.storage.delete(task_id)

    def toggle_task_status(self, task_id: str) -> Task:
        """
        Toggle task between pending and completed.

        Args:
            task_id: ID of task to toggle

        Returns:
            Task with updated status

        Raises:
            ValueError: If task_id not found
        """
        existing_task = self.storage.get(task_id)
        if existing_task is None:
            raise ValueError(f"Task with ID '{task_id}' not found")

        existing_task.toggle_status()
        return self.storage.update(task_id, existing_task)

    def get_task_count(self) -> int:
        """
        Return total number of tasks.

        Returns:
            Number of tasks (0 if none exist)
        """
        return len(self.storage.get_all())
